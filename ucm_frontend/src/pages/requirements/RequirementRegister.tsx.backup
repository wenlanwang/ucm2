import { useState, useEffect, useRef } from 'react';
import { Card, Steps, Upload, Button, message, Table, DatePicker, Modal, Select, Input, Tag, Space, Row, Col, Alert } from 'antd';
import { InboxOutlined, CheckCircleOutlined, CloseCircleOutlined, EditOutlined, DeleteOutlined, CopyOutlined, UploadOutlined, PlusOutlined } from '@ant-design/icons';
import type { UploadProps } from 'antd';
import dayjs from 'dayjs';
import api from '../../services/api';
import { useAuthStore } from '../../store/useAuthStore';

const { Dragger } = Upload;
const { Option } = Select;

interface ExcelRow {
  [key: string]: any;
  rowIndex: number;
}

interface ValidationResult {
  row_index: number;
  errors: { [key: string]: string };
  warnings: { [key: string]: string };
}

interface ManufacturerInfo {
  id: number;
  device_type: string;
  manufacturer: string;
  version: string;
  auth_method: string;
}

export default function RequirementRegister() {
  const [requirementType, setRequirementType] = useState<'import' | 'modify' | 'delete'>('import');
  const [excelData, setExcelData] = useState<ExcelRow[]>([]);
  const [excelHeaders, setExcelHeaders] = useState<string[]>([]);
  const [validationResults, setValidationResults] = useState<ValidationResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [ucmChangeDate, setUcmChangeDate] = useState<dayjs.Dayjs | null>(null);
  const [showDateModal, setShowDateModal] = useState(false);
  const [columnOptions, setColumnOptions] = useState<{ [key: string]: string[] }>({});
  const [editingCell, setEditingCell] = useState<{ rowIndex: number; column: string } | null>(null);
  const [editValue, setEditValue] = useState('');
  const [manufacturerData, setManufacturerData] = useState<ManufacturerInfo[]>([]);
  const [cascadeOptions, setCascadeOptions] = useState<{
    deviceTypes: string[];
    manufacturers: { [deviceType: string]: string[] };
    versions: { [key: string]: string[] };
    loginMethods: { [key: string]: string[] };
  }>({
    deviceTypes: [],
    manufacturers: {},
    versions: {},
    loginMethods: {}
  });
  const [clearedCells, setClearedCells] = useState<Set<string>>(new Set());
  const [ucmConfig, setUcmConfig] = useState({
    wednesday_deadline_hours: 7,
    saturday_deadline_hours: 31
  });
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { user } = useAuthStore();

  const requirementTypeText = {
    import: 'å¯¼å…¥',
    modify: 'ä¿®æ”¹',
    delete: 'åˆ é™¤'
  };

  useEffect(() => {
    console.log('RequirementRegisterç»„ä»¶æŒ‚è½½ï¼Œå¼€å§‹åŠ è½½æ•°æ?..');
    loadColumnOptions();
    loadManufacturerData();
    loadUCMDateConfig();
    setClearedCells(new Set()); // æ¸…ç©ºå·²æ¸…ç©ºæ ‡è®?  }, []);

  const loadUCMDateConfig = async () => {
    try {
      const response = await api.get('/ucm-date-config/');
      setUcmConfig(response.data);
    } catch (error) {
      console.error('åŠ è½½UCMæ—¥æœŸé…ç½®å¤±è´¥:', error);
    }
  };

  const loadColumnOptions = async () => {
    try {
      const response = await api.get('/column-options/');
      const options: { [key: string]: string[] } = {};
      
      // æ”¯æŒåˆ†é¡µæ ¼å¼å’Œç›´æ¥æ•°ç»„æ ¼å¼?      let data = response.data;
      if (data && data.results && Array.isArray(data.results)) {
        // åˆ†é¡µæ ¼å¼
        data = data.results;
      } else if (!Array.isArray(data)) {
        console.error('æ•°æ®æ ¼å¼é”™è¯¯ï¼ŒæœŸæœ›æ•°ç»?', response.data);
        return;
      }
      
      data.forEach((item: any) => {
        if (!options[item.column_name]) {
          options[item.column_name] = [];
        }
        options[item.column_name].push(item.option_value);
      });
      setColumnOptions(options);
    } catch (error) {
      console.error('åŠ è½½åˆ—å¯é€‰å€¼å¤±è´?', error);
    }
  };

  const loadManufacturerData = async () => {
    try {
      console.log('å¼€å§‹åŠ è½½å‚å•†ç‰ˆæœ¬æ•°æ?..');
      const response = await api.get('/manufacturers/');
      console.log('APIå“åº”:', response);
      
      // æ”¯æŒåˆ†é¡µæ ¼å¼å’Œç›´æ¥æ•°ç»„æ ¼å¼?      let data = response.data;
      if (data && data.results && Array.isArray(data.results)) {
        // åˆ†é¡µæ ¼å¼
        data = data.results;
      } else if (!Array.isArray(data)) {
        console.error('æ•°æ®æ ¼å¼é”™è¯¯ï¼ŒæœŸæœ›æ•°ç»?', response.data);
        return;
      }
      
      console.log('å‚å•†ç‰ˆæœ¬åŸå§‹æ•°æ®:', data);
      
      // æ„å»ºçº§è”é€‰é¡¹
      const deviceTypes = new Set<string>();
      const manufacturers: { [key: string]: Set<string> } = {};
      const versions: { [key: string]: Set<string> } = {};
      const loginMethods: { [key: string]: Set<string> } = {};
      
      data.forEach((item: ManufacturerInfo) => {
        // è®¾å¤‡ç±»å‹
        deviceTypes.add(item.device_type);
        
        // å‚å•†ï¼ˆæŒ‰è®¾å¤‡ç±»å‹åˆ†ç»„ï¼?        if (!manufacturers[item.device_type]) {
          manufacturers[item.device_type] = new Set();
        }
        manufacturers[item.device_type].add(item.manufacturer);
        
        // ç‰ˆæœ¬ï¼ˆæŒ‰è®¾å¤‡ç±»å‹+å‚å•†åˆ†ç»„ï¼?        const versionKey = `${item.device_type}-${item.manufacturer}`;
        if (!versions[versionKey]) {
          versions[versionKey] = new Set();
        }
        versions[versionKey].add(item.version);
      });
      
      const finalOptions = {
        deviceTypes: Array.from(deviceTypes),
        manufacturers: Object.fromEntries(
          Object.entries(manufacturers).map(([k, v]) => [k, Array.from(v)])
        ),
        versions: Object.fromEntries(
          Object.entries(versions).map(([k, v]) => [k, Array.from(v)])
        )
      };
      
      console.log('çº§è”é€‰é¡¹æ•°æ®:', finalOptions);
      
      setManufacturerData(data);
      setCascadeOptions(finalOptions);
    } catch (error) {
      console.error('åŠ è½½å‚å•†ç‰ˆæœ¬æ•°æ®å¤±è´¥:', error);
    }
  };

  const uploadProps: UploadProps = {
    name: 'file',
    multiple: false,
    accept: '.xls',
    beforeUpload: (file) => {
      const isXls = file.name.endsWith('.xls');
      if (!isXls) {
        message.error('åªèƒ½ä¸Šä¼  .xls æ ¼å¼çš„æ–‡ä»?');
        return Upload.LIST_IGNORE;
      }
      return false;
    },
    onChange(info) {
      handleUpload(info.file);
    },
  };

  const handleUpload = async (file: any) => {
    setLoading(true);
    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('requirement_type', requirementType);

      const response = await api.post('/requirements/upload_excel/', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      });

      if (response.data.headers && response.data.data) {
        setExcelHeaders(response.data.headers);
        const dataWithIndex = response.data.data.map((row: any, index: number) => ({
          ...row,
          rowIndex: index + 1
        }));
        setExcelData(dataWithIndex);
        setCurrentStep(1);
        message.success(`æˆåŠŸè§£æ ${response.data.total_rows} æ¡è®°å½•`);
      }
    } catch (error: any) {
      message.error(error.response?.data?.error || 'æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  // æ ‡è®°å•å…ƒæ ¼ä¸ºå·²æ¸…ç©?  const markCellAsCleared = (rowIndex: number, column: string) => {
    setClearedCells(prev => {
      const newSet = new Set(prev);
      newSet.add(`${rowIndex}-${column}`);
      return newSet;
    });
  };

  // æ¸…é™¤å•å…ƒæ ¼çš„å·²æ¸…ç©ºæ ‡è®?  const clearCellClearedMark = (rowIndex: number, column: string) => {
    setClearedCells(prev => {
      const newSet = new Set(prev);
      newSet.delete(`${rowIndex}-${column}`);
      return newSet;
    });
  };

  // å¯¼å…¥éœ€æ±‚æŒ‰é’®ç‚¹å‡?  const handleImportClick = () => {
    fileInputRef.current?.click();
  };

  // æ–‡ä»¶é€‰æ‹©å¤„ç†
  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      handleUpload(file);
      // æ¸…ç©ºinputå€¼ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
      event.target.value = '';
    }
  };

  // ä»æ¨¡æ¿åŠ è½½è¡¨å¤?  const loadTemplateHeaders = async () => {
    try {
      const response = await api.get(`/templates/?template_type=${requirementType}`);
      const templates = response.data.results || response.data;
      if (templates.length > 0) {
        const headers = templates[0].column_definitions || [];
        setExcelHeaders(headers);
      } else {
        // ä½¿ç”¨é»˜è®¤è¡¨å¤´
        setExcelHeaders(['åç§°', 'è®¾å¤‡ç±»å‹', 'å‚å•†', 'ç‰ˆæœ¬', 'IP', 'è®¤è¯æ–¹å¼']);
      }
    } catch (error) {
      console.error('åŠ è½½æ¨¡æ¿è¡¨å¤´å¤±è´¥:', error);
      // ä½¿ç”¨é»˜è®¤è¡¨å¤´
      setExcelHeaders(['åç§°', 'è®¾å¤‡ç±»å‹', 'å‚å•†', 'ç‰ˆæœ¬', 'IP', 'è®¤è¯æ–¹å¼']);
    }
  };

  // ä¿®æ”¹handleAddRowå‡½æ•°
  const handleAddRow = async () => {
    // å¦‚æœæ²¡æœ‰è¡¨å¤´ï¼Œä»æ¨¡æ¿è·å–
    if (excelHeaders.length === 0) {
      await loadTemplateHeaders();
    }
    
    const newRow: ExcelRow = {
      rowIndex: excelData.length + 1
    };
    // ä½¿ç”¨æœ€æ–°çš„excelHeaders
    const headers = excelHeaders.length > 0 ? excelHeaders : ['åç§°', 'è®¾å¤‡ç±»å‹', 'å‚å•†', 'ç‰ˆæœ¬', 'IP', 'è®¤è¯æ–¹å¼'];
    headers.forEach(header => {
      newRow[header] = '';
    });
    setExcelData([...excelData, newRow]);
  };

  // UCMæ—¥æœŸè®¡ç®—å‡½æ•°
  const getSelectableDates = () => {
    const dates = [];
    const now = dayjs();
    
    // æœ¬å‘¨ä¸?    const thisWednesday = now.day(3);
    // æœ¬å‘¨å…?    const thisSaturday = now.day(6);
    // ä¸‹å‘¨ä¸?    const nextWednesday = now.day(10);
    // ä¸‹å‘¨å…?    const nextSaturday = now.day(13);
    
    // åªæ·»åŠ æœªæ¥çš„æ—¥æœŸ
    if (thisWednesday.isAfter(now, 'day') || thisWednesday.isSame(now, 'day')) {
      dates.push(thisWednesday);
    }
    if (thisSaturday.isAfter(now, 'day') || thisSaturday.isSame(now, 'day')) {
      dates.push(thisSaturday);
    }
    dates.push(nextWednesday);
    dates.push(nextSaturday);
    
    return dates;
  };

  // æ£€æŸ¥æ—¥æœŸæ˜¯å¦å¯é€?  const isDateSelectable = (date: dayjs.Dayjs) => {
    const now = dayjs();
    const dayOfWeek = date.day(); // 0=å‘¨æ—¥, 3=å‘¨ä¸‰, 6=å‘¨å…­
    
    // å¿…é¡»æ˜¯å‘¨ä¸‰æˆ–å‘¨å…­
    if (dayOfWeek !== 3 && dayOfWeek !== 6) {
      return false;
    }
    
    // ä¸èƒ½æ˜¯è¿‡å»çš„æ—¥æœŸ
    if (date.isBefore(now, 'day')) {
      return false;
    }
    
    // æ£€æŸ¥æˆªæ­¢æ—¶é—´ï¼ˆç²¾ç¡®åˆ°åˆ†é’Ÿï¼‰
    const deadline = dayOfWeek === 3 
      ? date.subtract(ucmConfig.wednesday_deadline_hours, 'hour')
      : date.subtract(ucmConfig.saturday_deadline_hours, 'hour');
      
    if (now.isAfter(deadline)) {
      return false;
    }
    
    return true;
  };

  // DatePickerçš„disabledDate
  const disabledDate = (current: dayjs.Dayjs) => {
    // åªå…è®¸æœ¬å‘¨å’Œä¸‹å‘¨çš„å‘¨ä¸‰ã€å‘¨å…?    const selectableDates = getSelectableDates();
    const dateStr = current.format('YYYY-MM-DD');
    
    return !selectableDates.some(d => d.format('YYYY-MM-DD') === dateStr);
  };

  const handleValidate = async () => {
    setLoading(true);
    try {
      const response = await api.post('/requirements/validate_data/', {
        requirement_type: requirementType,
        excel_data: excelData
      });

      if (response.data.valid) {
        setValidationResults(response.data.validation_results);
        setCurrentStep(2);
        message.success('æ ¡éªŒå®Œæˆ');
      } else if (response.data.error_type === 'column_mismatch') {
        message.error(`åˆ—åä¸åŒ¹é…ï¼Œç¼ºå°‘: ${response.data.missing_columns.join(', ')}`);
      }
    } catch (error: any) {
      message.error(error.response?.data?.error || 'æ ¡éªŒå¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  const getCellStyle = (rowIndex: number, column: string) => {
    const result = validationResults.find(r => r.row_index === rowIndex - 1);
    const isCleared = clearedCells.has(`${rowIndex}-${column}`);

    const hasError = result?.errors[column];
    const hasWarning = result?.warnings[column];

    if (hasError) {
      return {
        border: '2px solid #ff4d4f',
        backgroundColor: '#fff1f0'
      };
    }
    if (hasWarning) {
      return {
        border: '2px solid #faad14',
        backgroundColor: '#fffbe6'
      };
    }
    if (isCleared) {
      return {
        border: '2px solid #ff4d4f',
        backgroundColor: '#fff1f0'
      };
    }
    return {};
  };

  const getValidationIcon = (rowIndex: number) => {
    const result = validationResults.find(r => r.row_index === rowIndex - 1);
    if (!result) return null;

    const hasError = Object.keys(result.errors).length > 0;
    const hasWarning = Object.keys(result.warnings).length > 0;

    if (hasError) {
      return <CloseCircleOutlined style={{ color: '#ff4d4f' }} />;
    }
    if (hasWarning) {
      return <CloseCircleOutlined style={{ color: '#faad14' }} />;
    }
    return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
  };

  const handleCellEdit = (rowIndex: number, column: string, currentValue: string) => {
    setEditingCell({ rowIndex, column });
    setEditValue(currentValue);
    clearCellClearedMark(rowIndex, column); // æ¸…é™¤å·²æ¸…ç©ºæ ‡è®?  };

  const saveCellEdit = async () => {
    if (!editingCell) return;

    const newData = [...excelData];
    const rowIndex = newData.findIndex(row => row.rowIndex === editingCell.rowIndex);
    if (rowIndex >= 0) {
      newData[rowIndex][editingCell.column] = editValue;
      setExcelData(newData);

      // é‡æ–°æ ¡éªŒè¯¥è¡Œ
      const rowToValidate = [newData[rowIndex]];
      try {
        const response = await api.post('/requirements/validate_data/', {
          requirement_type: requirementType,
          excel_data: rowToValidate
        });

        if (response.data.valid) {
          const newValidationResults = [...validationResults];
          const validationIndex = newValidationResults.findIndex(r => r.row_index === editingCell.rowIndex - 1);
          if (validationIndex >= 0) {
            newValidationResults[validationIndex] = response.data.validation_results[0];
            setValidationResults(newValidationResults);
          }
        }
      } catch (error) {
        console.error('é‡æ–°æ ¡éªŒå¤±è´¥:', error);
      }
    }

    setEditingCell(null);
    setEditValue('');
  };



  const handleDeleteRow = (rowIndex: number) => {
    const newData = excelData.filter(row => row.rowIndex !== rowIndex);
    setExcelData(newData.map((row, index) => ({
      ...row,
      rowIndex: index + 1
    })));
  };

  const handleCopyRow = (rowIndex: number) => {
    const rowToCopy = excelData.find(row => row.rowIndex === rowIndex);
    if (rowToCopy) {
      const newRow = {
        ...rowToCopy,
        rowIndex: excelData.length + 1
      };
      setExcelData([...excelData, newRow]);
    }
  };

  const hasValidationErrors = () => {
    return validationResults.some(result => Object.keys(result.errors).length > 0);
  };

  const handleSubmit = () => {
    console.log('handleSubmit called, hasValidationErrors:', hasValidationErrors());
    if (hasValidationErrors()) {
      message.error('å­˜åœ¨æ ¡éªŒé”™è¯¯ï¼Œæ— æ³•æäº?);
      return;
    }
    console.log('Opening date modal');
    setShowDateModal(true);
  };

  const confirmSubmit = async () => {
    console.log('confirmSubmit called, ucmChangeDate:', ucmChangeDate);
    if (!ucmChangeDate) {
      message.error('è¯·é€‰æ‹©UCMå˜æ›´æ—¥æœŸ');
      return;
    }

    setSubmitting(true);
    try {
      const response = await api.post('/requirements/submit_requirement/', {
        requirement_type: requirementType,
        ucm_change_date: ucmChangeDate.format('YYYY-MM-DD'),
        excel_data: excelData,
        validation_results: validationResults
      });

      if (response.data.success) {
        message.success(response.data.message);
        setShowDateModal(false);
        // é‡ç½®è¡¨å•
        setCurrentStep(0);
        setExcelData([]);
        setValidationResults([]);
        setUcmChangeDate(null);
      }
    } catch (error: any) {
      console.error('æäº¤é”™è¯¯:', error);
      const errorData = error.response?.data;
      
      if (errorData?.error === 'å­˜åœ¨é‡å¤è®°å½•' && errorData?.duplicate_records) {
        const duplicates = errorData.duplicate_records;
        
        // æ„å»ºé‡å¤è®°å½•è¯¦ç»†ä¿¡æ¯
        const duplicateInfo = duplicates.map((dup: any, idx: number) => {
          const deviceName = dup.device_name || 'æœªå‘½åè®¾å¤?;
          return `${idx + 1}. åç§°: ${deviceName}, IP: ${dup.ip}, å·²ç™»è®°æ—¥æœ? ${dup.existing_date}`;
        }).join('\n');
        
        // ä½¿ç”¨Promiseæ¥å¤„ç†Modal.confirmï¼Œç¡®ä¿å¼‚æ­¥æ“ä½œæ­£ç¡®æ‰§è¡?        const handleDuplicate = async () => {
          return new Promise<void>((resolve) => {
            Modal.confirm({
              title: 'å‘ç°é‡å¤è®°å½•',
              width: 600,
              content: (
                <div style={{ maxHeight: '400px', overflow: 'auto' }}>
                  <Alert
                    message={`å‘ç° ${duplicates.length} æ¡é‡å¤è®°å½•`}
                    description={
                      <pre style={{ 
                        background: '#f5f5f5', 
                        padding: '10px', 
                        borderRadius: '4px',
                        whiteSpace: 'pre-wrap',
                        fontSize: '12px'
                      }}>
                        {duplicateInfo}
                      </pre>
                    }
                    type="warning"
                    showIcon
                    style={{ marginBottom: '16px' }}
                  />
                  <p>æ‚¨å¯ä»¥é€‰æ‹©ï¼?/p>
                  <ul>
                    <li><strong>ç»§ç»­æäº¤ï¼?/strong>ä»…æäº¤éé‡å¤çš„è®°å½?/li>
                    <li><strong>å–æ¶ˆï¼?/strong>è¿”å›ä¿®æ”¹æ•°æ®</li>
                  </ul>
                </div>
              ),
              okText: 'ç»§ç»­æäº¤',
              cancelText: 'å–æ¶ˆ',
              onOk: async () => {
                // è¿‡æ»¤æ‰é‡å¤è®°å½•åé‡æ–°æäº¤
                const duplicateIps = duplicates.map((dup: any) => dup.ip);
                const filteredData = excelData.filter(row => !duplicateIps.includes(row.IP));
                
                // åŒæ—¶è¿‡æ»¤å¯¹åº”çš„æ ¡éªŒç»“æ?                const filteredValidationResults = validationResults.filter((result) => {
                  const rowIndex = result.row_index;
                  const correspondingRow = excelData[rowIndex];
                  return correspondingRow && !duplicateIps.includes(correspondingRow.IP);
                });
                
                if (filteredData.length > 0) {
                  try {
                    setSubmitting(true);
                    const response = await api.post('/requirements/submit_requirement/', {
                      requirement_type: requirementType,
                      ucm_change_date: ucmChangeDate.format('YYYY-MM-DD'),
                      excel_data: filteredData,
                      validation_results: filteredValidationResults
                    });
                    
                    if (response.data.success) {
                      const submittedCount = response.data.message.match(/\d+/);
                      message.success(`æˆåŠŸç™»è®° ${submittedCount ? submittedCount[0] : filteredData.length} æ¡éœ€æ±‚ï¼ˆå·²è·³è¿?${duplicates.length} æ¡é‡å¤è®°å½•ï¼‰`);
                      setShowDateModal(false);
                      setCurrentStep(0);
                      setExcelData([]);
                      setValidationResults([]);
                      setUcmChangeDate(null);
                    }
                  } catch (err: any) {
                    console.error('é‡æ–°æäº¤å¤±è´¥:', err);
                    message.error(err.response?.data?.error || 'æäº¤å¤±è´¥');
                  } finally {
                    setSubmitting(false);
                    resolve();
                  }
                } else {
                  message.warning('æ‰€æœ‰è®°å½•å‡ä¸ºé‡å¤è®°å½•ï¼Œæ²¡æœ‰å¯æäº¤çš„æ•°æ®');
                  resolve();
                }
              },
              onCancel: () => {
                resolve();
              }
            });
          });
        };
        
        // æ‰§è¡Œé‡å¤è®°å½•å¤„ç†
        handleDuplicate().catch(err => {
          console.error('å¤„ç†é‡å¤è®°å½•å¤±è´¥:', err);
          message.error('å¤„ç†é‡å¤è®°å½•æ—¶å‘ç”Ÿé”™è¯?);
        });
        
      } else {
        // å…¶ä»–é”™è¯¯
        const errorMessage = errorData?.error || error.message || 'æäº¤å¤±è´¥';
        message.error({
          content: errorMessage,
          duration: 5,
        });
      }
    } finally {
      setSubmitting(false);
    }
  };

  const columns = [
    {
      title: 'åºå·',
      dataIndex: 'rowIndex',
      width: 60,
      fixed: 'left' as const,
    },
    {
      title: 'æ ¡éªŒ',
      width: 60,
      fixed: 'left' as const,
      render: (_: any, record: ExcelRow) => getValidationIcon(record.rowIndex),
    },
    ...excelHeaders.map(header => ({
      title: header,
      dataIndex: header,
      width: 150,
      render: (value: any, record: ExcelRow) => {
        const isEditing = editingCell?.rowIndex === record.rowIndex && editingCell?.column === header;
        
        if (isEditing) {
          // åˆ—å¯é€‰å€¼ä¸‹æ‹‰é€‰æ‹©ï¼ˆä¼˜å…ˆæ£€æŸ¥ï¼Œç¡®ä¿'åˆ†ç»„'ç­‰åˆ—å¯ä»¥ä½¿ç”¨ä¸‹æ‹‰ï¼?          if (columnOptions[header] && columnOptions[header].length > 0) {
            return (
              <Select
                value={editValue}
                onChange={(val) => setEditValue(val)}
                onBlur={saveCellEdit}
                onPressEnter={saveCellEdit}
                autoFocus
                style={{ width: '100%' }}
                open
              >
                {columnOptions[header].map((option: string) => (
                  <Option key={option} value={option}>{option}</Option>
                ))}
              </Select>
            );
          }
          
          // çº§è”ä¸‹æ‹‰é€‰æ‹©ï¼šè®¾å¤‡ç±»å?          if (header === 'è®¾å¤‡ç±»å‹') {
            return (
              <Select
                value={editValue}
                onChange={(val) => {
                  setEditValue(val);
                  // æ¸…ç©ºå…³è”å­—æ®µï¼ˆä¸å†æ¸…ç©ºè®¤è¯æ–¹å¼ï¼‰
                  const newData = [...excelData];
                  const rowIndex = newData.findIndex(row => row.rowIndex === record.rowIndex);
                  if (rowIndex >= 0) {
                    // æ¸…ç©ºå‚å•†å¹¶æ ‡è®?                    if (newData[rowIndex]['å‚å•†']) {
                      markCellAsCleared(record.rowIndex, 'å‚å•†');
                      newData[rowIndex]['å‚å•†'] = '';
                    }
                    // æ¸…ç©ºç‰ˆæœ¬å¹¶æ ‡è®?                    if (newData[rowIndex]['ç‰ˆæœ¬']) {
                      markCellAsCleared(record.rowIndex, 'ç‰ˆæœ¬');
                      newData[rowIndex]['ç‰ˆæœ¬'] = '';
                    }
                    setExcelData(newData);
                  }
                }}
                onBlur={saveCellEdit}
                onPressEnter={saveCellEdit}
                autoFocus
                style={{ width: '100%' }}
              >
                {cascadeOptions.deviceTypes.map((option: string) => (
                  <Option key={option} value={option}>{option}</Option>
                ))}
              </Select>
            );
          }
          
          // çº§è”ä¸‹æ‹‰é€‰æ‹©ï¼šå‚å•?          if (header === 'å‚å•†') {
            const deviceType = record['è®¾å¤‡ç±»å‹'];
            const manufacturers = deviceType ? cascadeOptions.manufacturers[deviceType] || [] : [];
            return (
              <Select
                value={editValue}
                onChange={(val) => {
                  setEditValue(val);
                  // æ¸…ç©ºå…³è”å­—æ®µï¼ˆä¸å†æ¸…ç©ºè®¤è¯æ–¹å¼ï¼‰
                  const newData = [...excelData];
                  const rowIndex = newData.findIndex(row => row.rowIndex === record.rowIndex);
                  if (rowIndex >= 0) {
                    // æ¸…ç©ºç‰ˆæœ¬å¹¶æ ‡è®?                    if (newData[rowIndex]['ç‰ˆæœ¬']) {
                      markCellAsCleared(record.rowIndex, 'ç‰ˆæœ¬');
                      newData[rowIndex]['ç‰ˆæœ¬'] = '';
                    }
                    setExcelData(newData);
                  }
                }}
                onBlur={saveCellEdit}
                onPressEnter={saveCellEdit}
                autoFocus
                style={{ width: '100%' }}
              >
                {manufacturers.map((option: string) => (
                  <Option key={option} value={option}>{option}</Option>
                ))}
              </Select>
            );
          }
          
          // çº§è”ä¸‹æ‹‰é€‰æ‹©ï¼šç‰ˆæœ?          if (header === 'ç‰ˆæœ¬') {
            const deviceType = record['è®¾å¤‡ç±»å‹'];
            const manufacturer = record['å‚å•†'];
            const versionKey = `${deviceType}-${manufacturer}`;
            const versions = (deviceType && manufacturer) ? cascadeOptions.versions[versionKey] || [] : [];
            return (
              <Select
                value={editValue}
                onChange={(val) => {
                  setEditValue(val);
                  // ä¸å†æ¸…ç©ºè®¤è¯æ–¹å¼ï¼Œè§£é™¤çº§è”å…³è?                  const newData = [...excelData];
                  const rowIndex = newData.findIndex(row => row.rowIndex === record.rowIndex);
                  if (rowIndex >= 0) {
                    setExcelData(newData);
                  }
                }}
                onBlur={saveCellEdit}
                onPressEnter={saveCellEdit}
                autoFocus
                style={{ width: '100%' }}
              >
                {versions.map((option: string) => (
                  <Option key={option} value={option}>{option}</Option>
                ))}
              </Select>
            );
          }
          
          // æ™®é€šè¾“å…¥æ¡†ï¼ˆè®¤è¯æ–¹å¼ä¹Ÿä½¿ç”¨æ™®é€šè¾“å…¥æ¡†ï¼Œè§£é™¤çº§è”å…³è”ï¼‰
          if (header === 'è®¤è¯æ–¹å¼') {
            return (
              <Input
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                onBlur={saveCellEdit}
                onPressEnter={saveCellEdit}
                autoFocus
              />
            );
          }
          
          // æ™®é€šè¾“å…¥æ¡†
          return (
            <Input
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onBlur={saveCellEdit}
              onPressEnter={saveCellEdit}
              autoFocus
            />
          );
        }

        return (
          <div
            onClick={() => handleCellEdit(record.rowIndex, header, value || '')}
            style={{
              cursor: 'pointer',
              minHeight: '40px',
              padding: '8px',
              display: 'flex',
              alignItems: 'center',
              ...getCellStyle(record.rowIndex, header)
            }}
          >
            {value || ''}
          </div>
        );
      },
    })),
    {
      title: 'æ“ä½œ',
      width: 120,
      fixed: 'right' as const,
      render: (_: any, record: ExcelRow) => (
        <Space>
          <Button
            size="small"
            icon={<CopyOutlined />}
            onClick={() => handleCopyRow(record.rowIndex)}
          />
          <Button
            size="small"
            danger
            icon={<DeleteOutlined />}
            onClick={() => handleDeleteRow(record.rowIndex)}
          />
        </Space>
      ),
    },
  ];

  return (
    <div>
      <h1 style={{ marginBottom: 24 }}>éœ€æ±‚ç™»è®?/h1>
      
      <Card>
        {/* éœ€æ±‚ç±»å‹é€‰æ‹©å’Œæ“ä½œæŒ‰é’?*/}
        <div style={{ marginBottom: 16 }}>
          <Space>
            <strong>éœ€æ±‚ç±»å‹ï¼š</strong>
            <Select 
              value={requirementType} 
              onChange={(value) => setRequirementType(value)} 
              style={{ width: 200 }}
            >
              <Option value="import">å¯¼å…¥</Option>
              <Option value="modify">ä¿®æ”¹</Option>
              <Option value="delete">åˆ é™¤</Option>
            </Select>
            
            {/* å¯¼å…¥éœ€æ±‚æŒ‰é’®å’Œæ–‡ä»¶è¾“å…¥ */}
            <input
              type="file"
              ref={fileInputRef}
              style={{ display: 'none' }}
              accept=".xls"
              onChange={handleFileSelect}
            />
            <Button 
              type="primary" 
              icon={<UploadOutlined />} 
              onClick={handleImportClick}
            >
              å¯¼å…¥éœ€æ±?            </Button>
            
            {/* æ–°å¢è¡ŒæŒ‰é’?*/}
            <Button 
              type="primary" 
              icon={<PlusOutlined />} 
              onClick={handleAddRow}
            >
              æ–°å¢è¡?            </Button>
          </Space>
        </div>

        {/* æç¤ºæ–‡å­— */}
        <Alert
          message="æç¤º"
          description="è¯·ç‚¹å‡?æ–°å¢è¡?åˆ›å»ºéœ€æ±‚ï¼Œæˆ–ç‚¹å‡?å¯¼å…¥éœ€æ±?ä»Excelæ–‡ä»¶å¯¼å…¥"
          type="info"
          style={{ marginBottom: 16 }}
        />

        {/* UCMå˜æ›´æ—¥æœŸ */}
        <div style={{ marginBottom: 16 }}>
          <strong>UCMå˜æ›´æ—¥æœŸï¼?/strong>
          <DatePicker
            value={ucmChangeDate}
            onChange={setUcmChangeDate}
            disabledDate={disabledDate}
            style={{ width: 200 }}
            placeholder="è¯·é€‰æ‹©UCMå˜æ›´æ—¥æœŸ"
          />
        </div>

        {/* æ•°æ®è¡¨æ ¼ï¼ˆå§‹ç»ˆæ˜¾ç¤ºï¼‰ */}
        <Table
          columns={columns}
          dataSource={excelData}
          loading={loading}
          scroll={{ x: 'max-content' }}
          pagination={{
            pageSize: 10,
            showSizeChanger: true,
            showQuickJumper: true,
          }}
          bordered
          size="small"
        />

        {/* æ“ä½œæŒ‰é’® */}
        <div style={{ marginTop: 16, textAlign: 'right' }}>
          <Space>
            <Button onClick={handleValidate} loading={loading}>
              å¼€å§‹æ ¡éª?            </Button>
            <Button 
              type="primary" 
              onClick={handleSubmit}
              disabled={hasValidationErrors() || submitting || !ucmChangeDate}
              loading={submitting}
            >
              ç™»è®°éœ€æ±?            </Button>
          </Space>
        </div>
      </Card>
      
      <Modal
        title="é€‰æ‹©UCMå˜æ›´æ—¥æœŸ"
        open={showDateModal}
        onOk={confirmSubmit}
        onCancel={() => setShowDateModal(false)}
        confirmLoading={submitting}
      >
        <DatePicker
          value={ucmChangeDate}
          onChange={setUcmChangeDate}
          disabledDate={disabledDate}
          style={{ width: '100%' }}
          placeholder="è¯·é€‰æ‹©UCMå˜æ›´æ—¥æœŸ"
        />
      </Modal>
    </div>
  );
}
